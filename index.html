<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style type="text/css">
      .reveal p {
        text-align: left;
      }
      .reveal ul {
        display: block;
      }
      .reveal ol {
        display: block;
      }
    </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

<section data-markdown>
<script type="text/template">
## User-defined literals

As a every languages, C++ defines a lot of build-in literals:

```
auto i = 32;   // int
auto s = 32s;  // short
auto d = 4.27  // double
auto b = true; // bool
```

But what about defining your own?

```
auto distance = 42.5_km; // creates an object of type Dist
distance += 500_m; // is now 43 km
auto speed = my_voltage * 0.5_A
```
</script>
</section>

<section data-markdown>
<script type="text/template">
## User-defined literals

C++11 introduces the definition of custom literal operators:

```
Dist operator ""_km(long double d) {
  return distFromKm(d);
}
```
Also used in the standard library, e.g. `chrono`:

```
using namespace std::chrono_literals;

std::this_thread::sleep_for(250ms);

std::chrono::seconds hour_in_sec = 1h;
std::cout << hour_in_sec.count() << '\n'; // prints 3600
```
</script>
</section>

<section data-markdown>
<script type="text/template">
## User-defined literals

Also possible to define *raw* literals and perform checks on the actual characters given.

  - Allow to easily define value-like types (type with unit, etc.)
  - Improved type safety: define your type as classes and create them is easily as integers or doubles
  - Have types behaving exactly like built-in types
</script>
</section>

<section data-markdown>
<script type="text/template">
## User-defined literals

At Delta: we have to deal with voltage, current, etc.

  - Electrical measurements at the core of our system
  - Avoid type mismatch at compile-time
    - `Vdc != Vac`
    - `[A] * [V] == [W]`
  - Migrating type `Voltage` from a `typedef` to a class with UDL found some old bugs!
</script>
</section>

<section data-markdown>
<script type="text/template">
## Sum types: `std::optional`

To express that there *may* be value returned.

```
X parse_int(const std::string& s);
```

What type for `X`? Typical solutions:

  - :-( special value (`0`, `-1`, `MAX_INT`, ...)
  - :-( use a pointer
  - :-( return a separate error code
</script>
</section>

<section data-markdown>
<script type="text/template">
## Sum types: `std::optional`

```
std::optional<int> parse_int(const std::string& s);

auto oi = parse_int("22");
if(oi)
  use(*oid);
std::cout << "value: " << oi.value_or("****") << '\n';
```

  - Clearly expresses the intent (function signature)
  - No need for dynamic allocation or separate flag
  - No need for exceptions

</script>
</section>

<section data-markdown>
<script type="text/template">
## Algorithms library

Collection of *generic* algorithms useful in day-to-day programming

  - avoid common mistakes with loops (off-by-one, special cases)
  - are well-tested and optimized
  - can be composed / specialized
  - are named 

Base library not really new, but has now improved a lot with the newest features

  - lambdas
  - parallelism / vectorization (C++17)
  - really unleashed with *ranges* (C++20+)
</script>
</section>

<section data-markdown>
<script type="text/template">
## Algorithms library

Example: count even elements in a sequence

```
std::vector<int> nums = {7, 2, 8, 13, 21, 42};

int c = 0;
for(int i = 0; i < nums.size(); ++i)
{
  if(nums[i] % 2 == 0)
    ++c;
}
```

Using range-based for loop:

```
int c = 0;
for(const auto& n : nums)
{
  if(n % 2 == 0)
    ++c;
}
```
</script>
</section>

<section data-markdown>
<script type="text/template">
Using a standard algorithm

```
auto c = std::count_if(begin(nums), end(nums), [](auto n) {
  return n % 2 == 0; // predicate
});
```
  - No need for keeping the counter ourself
  - We can *filter* the value using any predicate
  - Similar algos: `find_if`, `copy_if`, `remove_if`, ...
  - Live example: https://godbolt.org/z/ff8Z7x
</script>
</section>

<section data-markdown> 
<script type="text/template">
## Execution policies 

3 different execution policies:
  - sequenced (`std::execution::seq`)
  - parallel (`std::execution::par`)
  - parallel unsequenced (`std::execution::par_unseq`)
    - enables vectorization

Most algorithms can be parameterized with the new policies

There are also new specific algos (reduce, scan, ...)
</script>
</section>

<section data-markdown> 
<script type="text/template">
## Ranges

 - Problem with algorithms:
   - Always the need to manipulate iterators
   - Composition of algorithms: not easy
 - Going one step further: *ranges*
   - A range is something that as a begin and an end
   - E.g. all containers are themselves ranges
 - Concepts of *smart iteration* and *adaptors*
   - Enables to chain computations in shell-like piping style
</script>
</section>

<section data-markdown> 
<script type="text/template">
## Example

I want to get even elements and double their values:

```
auto rng = nums | view::filter([](auto n) { return n % 2 == 0; })
                | view::transform([](auto n) { return 2 * n; });
```

</script>
</section>

<section data-markdown> 
<script type="text/template">
## Example



</script>
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				],
				history: true,
				transition: 'none',
			  width: 1200,
	      height: 700,
				margin: 0.05,
				minScale: 0.05,
				//width: '8 0%'
			});
		</script>
	</body>
</html>
